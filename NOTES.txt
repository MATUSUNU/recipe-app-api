
# THIS PROJECT INCLUDES
- APP DESIGN
- SYSTEM-SETUP
- PROJECT SETUP
- GITHUB ACTION
- TDD WITH DJANGO
- DATABASE
- USER MODEL
- ADMIN
- API
- DEPLOY TO AWS


=> app/ :- Django Project
=> app/core/ :- shared between multiple apps
=> app/user/ :- User related code
=> app/recipe/ :- Recipe(like Target Project) related

## Unit Tests
### - CODES WHICH TESTS CODES
### THE FLOW
- WRITE CODE -> WRITE TEST

### TDD
### - TEST WHICH DRIVENS CODES
### THE FLOW
- WRITE TEST -> WRITE CODE
### THE FULL FLOW
- WRITE TEST -> RUN TEST(fail) -> ADD FEATURE -> RUN TEST(pass) -> REFACTOR -> RUN TEST(pass)

## WE NEED INSTALLED:
- VS CODE
- DOCKER
- GIT


(1) CONFIGURE GITHUB ACC REPO & DOCKERHUB ACCOUNT
(2) AUTHENTICATION BETWEEN GITHUB & DOCKERHUB USING TOKEN
(3) WORKING ON PROJECT BY DOCKERIZED
TEST &
(4) USE DOCKER COMPOSE

## LINTING
- TOOLS TO CHECK CODE FORMATING
- HIGHLIGHTS ERRORS, TYPOS, FORMATTING ISSUES.
## HOW?
(1) INSTALL `flake8` pkg
(2) RUN IT THROUGH DOCKER COMPOSE
`docker compsoe run --rm <the-app-name> sh -c "flake8"`

## Testing
- Django test suite
- Setup tests per Django app
- Run tests through Docker compose
`docker compose run --rm <app name> sh -c "python manage.py test"`


## Creating the "project" folder inside the app    BY RUNNING THE SHELL CMD INSIDE CONTAINER TERMINAL
`docker compose run --rm <app name> sh -c "django-admin startproject app ."`
- the project app will be created under the app folder in this case! why? because we are RUNNING INSIDE THE "app"
`sudo docker compose run --rm app sh -c "django-admin startproject app ."`


## DJANGO TEST FRAMEWORK
- BASED ON THE "unittest" library
- DJANGO ADDS FEATURES
    - TEST CLIENT - DUMMY WEB BROWSER
    - SIMULATE AUTHENTICATION
    - TEMPORARY DATABASE
- DJANGO REST FRAMEWORK ADDS FEATURES
    - API TEST CLIENT

## TWO FORMATS
- USE EITHER test.py or test/    YOU CAN'T USE BOTH INSIDE ONE APP

## TEST CLASSES PROVIDED BY THE DJANGO
- SimpleTestCase
    - No database integration
    - Useful if no database is required for your test
    - Save time executing tests
- TestCase
    - Database integration
    - USEFUL FOR TESTING CODE THAT USES THE DATABASE


## WRITING TESTS
- IMPORT TEST CLASS
    - SimpleTestCase - NO DATABASE
    - TestCase - DATABASE
- IMPORT OBJECTS TO TEST
- DEFINE TEST CLASS
- ADD TEST METHOD
- SETUP INPUTS
- EXECUTE CODE TO BE TESTED
- CHECK OUTPUT


## WHAT IS MOCKING?
- OVERRIDE OR CHANGE BEHAVIOUR OF DEPENDENCIES
- AVOID UNINTENDED SIDE EFFECTS
- ISOLATE CODE BEING TESTED

## WHY USE MOCKING?
- AVOID RELYING ON EXTERNAL SERVICES
    - CAN'T GUARANTEE THEY WILL BE AVAILABLE
    - MAKES TESTS UNPREDICTABLE AND INCONSISTENT
- E.G. SENDING EMAIL

## HOW TO USE MOCK CODE?
- USE unittest.mock
    - MagicMock/Mock - Replace real objects
    - patch - Overrides codes for tests

## DJANGO REST FRAMEWORK APICLIENT
- BASED ON THE DJANGO'S TESTCLIENT
- MAKE REQUESTS
- CHECK RESULTS
- OVERRIDE AUTHENTICATION


## STEPS FOR CONFIGURING DATABASE
- CONFIGURE DJANGO
    - TELL DJANGO HOW TO CONNECT
- INSTALL DATABASE ADAPTOR DEPENDENCIES
    - INSTALL THE TOOL DJANGO USES TO CONNECT
- UPDATE PYTHON REQUIREMENTS

## INSTALL POSTGRESQL PSYCONPG2(python adopter) INSTALLATION OPTIONS
- psycopg2-binary
    - ok for development
    - not good for production
- psycopg2
    - compiles from source
    - required additional dependencies
    - easy to install with DOCKER

## INSTALLING PSYCOPG2
- LIST OF PACKAGE DEPENDENCIES IN DOCS
    - C COMPILER
    - PYTHON3-DEV
    - LIBPQ-DEV
- EQUIVALENT PACKAGES FOR ALPINE
    - POSTGRESQL-CLIENT [this guy is really required]
    - BUILD-BASE
    - POSTGRESQL-DEV
    - MUSL-DEV
- FOUND BY SEARCHING AND TRIAL AND ERROR
- DOCKER BEST PRACTICE:
    - CLEAN UP BUILD DEPENDENCIES


## SOLUTION FOR THE DJANGO STARTING FIRST AND CRASHING CUZ OF UNABLE TO CONNECT WITH POSTGRESQL    [THIS CAN BE CALLED  FIXING RACE CONDITION]
- MAKE DJANGO "WAIT FOR DB"
- CONTINUE WHEN DATABASE READY

CMD:
`docker compose rn --rm app sh -c "python manage.py startapp core"`
`docker compose run --rm app sh -c "python manage.py wait_for_db && flake8"`
`docker compose run --rm app sh -c "python manage.py test && flake8"`

## DJANGO USER MODEL
- FOUNDATION OF THE DJANGO AUTH SYSTEM
- DEFAULT USER MODEL
    - USERNAME INSTEAD OF EMAIL
    - NOT EASY TO CUSTOMIZE
- CREATE A CUSTOM MODEL FOR NEW PROJECTS
    - ALLOWS FOR USING "EMAIL" INSTEAD  OF USERNAME
    - FUTURE PROOF PROJECT FOR LATER CHANGES TO USER MODEL

## HOW TO CUSTOMIZE USER MODEL
- CREATE MODEL
    - BASE FROM "AbstractBaseUser" and "PermissionMixin"
- CREATE CUSTOM MANAGER
    - USED FOR CLI INTEGRATION
- SET "AUTH_USER_MODEL" IN settings.py

## COMMON ISSUES
- RUNNING MIGRATIONS BEFORE SETTING CUSTOM MODEL

## USER FIELDS
- email (EmailField)
- name (CharField)
- is_active (BooleanField)
- is_staff (BooleanField)

## CUSTOMISING THE DJANGO ADMIN
- CREATE CLASS BASED OFF ModelAdmin or UserAdmin
- OVERRIDE/SET CLASS VARIABLES

## DOCS IN DRF
- AUTO GENERATE DOCS (WITH THIRD PARTY LIBRARY)
    - drf-spectacular

## HOW IT WORKS
1. Generate "schema" file
2. Parse schema into GUI

## OpenAPI Schema
- standard for describing APIs
- Popular in industry
- Supported by most API documentation tools    like: Swagger

## Using a Schema
- Download and run in local Swagger instance
- Serve Swagger With API    [BEST]

## TYPES OF AUTHENTICATION
- BASIC
    - SEND USERNAME AND PASSWORD WITH EACH REQUEST
- TOKEN
    - USE A TOKEN IN THE "HTTP" HEADER
- JSON WEB TOKEN (JWT)
    - USE AN ACCESS AND REFRESH TOKEN
- session
    - use cookies
